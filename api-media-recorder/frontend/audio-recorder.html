<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>MediaRecorder API - Upload Demo</title>
  <link rel="stylesheet" href="home.css">
</head>

<body>
  <h2>üé§ Thu √Çm & G·ª≠i API</h2>

  <label for="qualitySelect">Ch·ªçn ch·∫•t l∆∞·ª£ng ghi √¢m:</label>
  <select id="qualitySelect">
    <option value="audio/webm;codecs=opus" selected>WebM Opus (m·∫∑c ƒë·ªãnh)</option>
    <option value="audio/wav">WAV (kh√¥ng n√©n)</option>
    <option value="audio/mp3">MP3 (n·∫øu tr√¨nh duy·ªát h·ªó tr·ª£)</option>
  </select>

  <div>
    <button id="startBtn">B·∫Øt ƒë·∫ßu ghi √¢m</button>
    <button id="stopBtn" disabled>D·ª´ng ghi √¢m</button>
    <button id="downloadBtn" disabled>T·∫£i file</button>
    <button id="uploadBtn" disabled>G·ª≠i API</button>
  </div>

  <div id="timer">00:00</div>

  <canvas id="waveform"></canvas>

  <audio id="audioPlayer" controls></audio>

  <div id="status"></div>

  <h3>B·∫£n ghi hi·ªán t·∫°i</h3>
  <div id="recordingsList"></div>

  <script>
    let mediaRecorder;
    let audioChunks = [];
    let audioBlob;
    let audioUrl;
    let audioPlayer = document.getElementById('audioPlayer');
    let startBtn = document.getElementById('startBtn');
    let stopBtn = document.getElementById('stopBtn');
    let downloadBtn = document.getElementById('downloadBtn');
    let uploadBtn = document.getElementById('uploadBtn');
    let statusDiv = document.getElementById('status');
    let timerDisplay = document.getElementById('timer');
    let qualitySelect = document.getElementById('qualitySelect');
    let recordingsList = document.getElementById('recordingsList');
    let waveformCanvas = document.getElementById('waveform');
    let canvasCtx = waveformCanvas.getContext('2d');
    let audioContext, analyser, sourceNode, dataArray, animationId;

    // Timer
    let seconds = 0;
    let timerInterval;

    function updateTimer() {
      seconds++;
      let mins = Math.floor(seconds / 60).toString().padStart(2, '0');
      let secs = (seconds % 60).toString().padStart(2, '0');
      timerDisplay.textContent = `${mins}:${secs}`;
    }

    function resetTimer() {
      clearInterval(timerInterval);
      seconds = 0;
      timerDisplay.textContent = '00:00';
    }

    // Waveform visualizer
    function initVisualizer(stream) {
      audioContext = new AudioContext();
      analyser = audioContext.createAnalyser();
      sourceNode = audioContext.createMediaStreamSource(stream);
      sourceNode.connect(analyser);
      analyser.fftSize = 2048;
      let bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);

      drawWaveform();
    }

    function drawWaveform() {
      animationId = requestAnimationFrame(drawWaveform);

      analyser.getByteTimeDomainData(dataArray);

      canvasCtx.fillStyle = '#222';
      canvasCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);

      canvasCtx.lineWidth = 2;
      canvasCtx.strokeStyle = '#4caf50';

      canvasCtx.beginPath();

      let sliceWidth = waveformCanvas.width * 1.0 / dataArray.length;
      let x = 0;

      for (let i = 0; i < dataArray.length; i++) {
        let v = dataArray[i] / 128.0;
        let y = v * waveformCanvas.height / 2;

        if (i === 0) {
          canvasCtx.moveTo(x, y);
        } else {
          canvasCtx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      canvasCtx.lineTo(waveformCanvas.width, waveformCanvas.height / 2);
      canvasCtx.stroke();
    }

    function stopVisualizer() {
      cancelAnimationFrame(animationId);
      if (audioContext) {
        audioContext.close();
      }
      canvasCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
    }

    // Resize canvas
    function resizeCanvas() {
      waveformCanvas.width = waveformCanvas.clientWidth;
      waveformCanvas.height = waveformCanvas.clientHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Start recording
    startBtn.onclick = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        resetTimer();
        timerInterval = setInterval(updateTimer, 1000);

        let selectedType = qualitySelect.value;
        if (!MediaRecorder.isTypeSupported(selectedType)) {
          statusDiv.textContent = `ƒê·ªãnh d·∫°ng ${selectedType} kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£, d√πng m·∫∑c ƒë·ªãnh WebM.`;
          selectedType = 'audio/webm;codecs=opus';
        }
        mediaRecorder = new MediaRecorder(stream, { mimeType: selectedType });

        audioChunks = [];
        mediaRecorder.ondataavailable = e => {
          if (e.data.size > 0) audioChunks.push(e.data);
        };

        mediaRecorder.onstart = () => {
          statusDiv.textContent = 'ƒêang ghi √¢m...';
          startBtn.disabled = true;
          stopBtn.disabled = false;
          downloadBtn.disabled = true;
          uploadBtn.disabled = true;
          audioPlayer.src = '';
          initVisualizer(stream);
        };

        mediaRecorder.onstop = () => {
          audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
          audioUrl = URL.createObjectURL(audioBlob);
          audioPlayer.src = audioUrl;
          statusDiv.textContent = 'ƒê√£ d·ª´ng ghi √¢m.';
          startBtn.disabled = false;
          stopBtn.disabled = true;
          downloadBtn.disabled = false;
          uploadBtn.disabled = false;
          clearInterval(timerInterval);
          stopVisualizer();

          // Th√™m b·∫£n ghi v√†o danh s√°ch
          addRecordingToList(audioBlob);
        };

        mediaRecorder.start();
      } catch (err) {
        statusDiv.textContent = 'L·ªói khi l·∫•y microphone ho·∫∑c kh√¥ng ƒë∆∞·ª£c ph√©p: ' + err.message;
      }
    };

    // Stop recording
    stopBtn.onclick = () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    };

    // Download recording
    downloadBtn.onclick = () => {
      if (!audioBlob) return;
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = audioUrl;
      a.download = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.${getExtensionByMimeType(audioBlob.type)}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    };

    // Upload recording
    uploadBtn.onclick = () => {
      if (!audioBlob) return;
      statusDiv.textContent = 'ƒêang g·ª≠i...';

      const formData = new FormData();
      formData.append('file', audioBlob, `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.${getExtensionByMimeType(audioBlob.type)}`);

      fetch('https://your-api-endpoint/upload', {
        method: 'POST',
        body: formData
      }).then(res => {
        if (res.ok) {
          statusDiv.textContent = 'G·ª≠i th√†nh c√¥ng!';
        } else {
          statusDiv.textContent = 'G·ª≠i th·∫•t b·∫°i: ' + res.statusText;
        }
      }).catch(err => {
        statusDiv.textContent = 'L·ªói g·ª≠i API: ' + err.message;
      });
    };

    // Danh s√°ch b·∫£n ghi
    let recordings = [];

    function addRecordingToList(blob) {
      const id = Date.now();
      recordings.push({ id, blob, url: URL.createObjectURL(blob) });
      renderRecordingsList();
    }

    function renderRecordingsList() {
      recordingsList.innerHTML = '';
      recordings.forEach((rec, index) => {  // l·∫•y th√™m index
        const div = document.createElement('div');
        div.className = 'recording-item';

        // Th√™m t√™n v·ªõi th·ª© t·ª±
        const title = document.createElement('div');
        title.textContent = `B·∫£n ghi ${index + 1}`;  // +1 ƒë·ªÉ b·∫Øt ƒë·∫ßu t·ª´ 1
        title.style.fontWeight = 'bold';
        title.style.marginBottom = '5px';

        const audioEl = document.createElement('audio');
        audioEl.controls = true;
        audioEl.src = rec.url;

        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'recording-actions';

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'X√≥a';
        deleteBtn.className = 'delete-btn';
        deleteBtn.onclick = () => {
          URL.revokeObjectURL(rec.url);
          recordings = recordings.filter(r => r.id !== rec.id);
          renderRecordingsList();
        };

        const uploadBtn = document.createElement('button');
        uploadBtn.textContent = 'G·ª≠i API';
        uploadBtn.className = 'upload-btn';
        uploadBtn.onclick = () => {
          uploadRecording(rec);
        };

        actionsDiv.appendChild(uploadBtn);
        actionsDiv.appendChild(deleteBtn);

        div.appendChild(title);      
        div.appendChild(audioEl);
        div.appendChild(actionsDiv);

        recordingsList.appendChild(div);
      });
    }

    function uploadRecording(recording) {
      statusDiv.textContent = `ƒêang g·ª≠i b·∫£n ghi ${new Date(recording.id).toLocaleTimeString()}...`;

      const formData = new FormData();
      formData.append('file', recording.blob, `recording_${new Date(recording.id).toISOString().replace(/[:.]/g, '-')}.${getExtensionByMimeType(recording.blob.type)}`);

      fetch('https://your-api-endpoint/upload', {
        method: 'POST',
        body: formData
      }).then(res => {
        if (res.ok) {
          statusDiv.textContent = 'G·ª≠i th√†nh c√¥ng b·∫£n ghi!';
        } else {
          statusDiv.textContent = 'G·ª≠i th·∫•t b·∫°i: ' + res.statusText;
        }
      }).catch(err => {
        statusDiv.textContent = 'L·ªói g·ª≠i API: ' + err.message;
      });
    }

    function getExtensionByMimeType(mime) {
      switch (mime) {
        case 'audio/webm':
        case 'audio/webm;codecs=opus':
          return 'webm';
        case 'audio/wav':
          return 'wav';
        case 'audio/mpeg':
          return 'mp3';
        default:
          return 'wav';
      }
    }
  </script>
</body>

</html>